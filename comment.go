// Copyright 2019 - now The https://github.com/nvwa-io/wago Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package wago

import (
	"fmt"
	"github.com/kataras/iris/core/errors"
	"github.com/nvwa-io/wago/util"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"regexp"
	"strings"
)

const (
	tagPrefix = "@prefix"
)

var (
	routeRegex = regexp.MustCompile(`@([\S]+)(?:(?:\s+)?)(\S+)?`)
)

type ControllerCommentRouter struct {
	Pkg            string // name of current controller's pkg name, e.g: package home, Pkg="home"
	Controller     string
	CommentRouters []CommentRouter
}

var (
	commentRouterTemplate = `// NOTICE: FILE SHOULDN'T BE DELETED
// routers listed below is auto generated by parsing controller files
// and all configurations will effect http routers

package router

import "github.com/nvwa-io/wago"

func init() {
{{.commentControllerRouter}}
}`

	commentRouterTemplateItem = `
    wago.CommentRouters["%s"] = append(wago.CommentRouters["%s"], wago.CommentRouter{
		Method:     "%s",
		Router:     "%s",
		HTTPMethod: %s,
	})
`
)

// rootDir, default is "controller"
func ParseRouter(rootDir ...string) {
	controllerDir := "controller"
	if len(rootDir) > 0 {
		controllerDir = rootDir[0]
	}

	// scan all level 1 sub dirs
	subDirs, err := util.ScanLevel1Dirs(controllerDir)
	if err != nil {
		log.Fatalln("failed to parse ", rootDir, ", err: ", err.Error())
	}

	controllerDirs := make([]string, 0, len(subDirs)+1)
	controllerDirs = append(controllerDirs, controllerDir) // set root controller dir at first pos
	controllerDirs = append(controllerDirs, subDirs...)

	// parse all comment routers in controller dir and it's sub dirs
	rootPkg := controllerDir
	for i, v := range controllerDirs {
		routers := parseAll(v)
		if i == 0 && len(routers) > 0 {
			rootPkg = routers[0].Pkg
		}

		for _, v := range routers {
			key := rootPkg
			if i > 0 {
				key = fmt.Sprintf("%s/%s/%s", rootPkg, v.Pkg, v.Controller)
			} else {
				key = fmt.Sprintf("%s/%s", v.Pkg, v.Controller)
			}
			CommentRouters[key] = v.CommentRouters
		}
	}

	code := genRouterCode()
	err = saveRouterFile("wago_auto_comment_router.go", code)
	if err != nil {
		log.Fatalln(fmt.Sprintf("failed to save auto generated router file, err=%s", err.Error()))
	}
}

// generate router codes
func genRouterCode() string {
	list := make([]string, 0)
	for key, routers := range CommentRouters {
		for _, v := range routers {
			httpMethodStr := fmt.Sprintf("[]string{\"%s\"}", strings.Join(v.HTTPMethod, "\",\""))
			item := fmt.Sprintf(commentRouterTemplateItem, key, key, v.Method, v.Router, httpMethodStr)
			list = append(list, item)
		}
	}

	return strings.Join(list, "")
}

// save auto-generated code to router file in project's router dir
func saveRouterFile(name, code string) error {
	//dir, err := os.Getwd()
	//if err != nil {
	//	log.Fatal("failed to get work dir: ", err.Error())
	//}

	if _, err := os.Stat("router"); err != nil {
		if !os.IsNotExist(err) {
			return err
		}

		err := os.Mkdir("router", 0755)
		if err != nil {
			return errors.New("failed to make dir router, err=" + err.Error())
		}
	}

	filename := fmt.Sprintf("./router/%s", name)
	f, err := os.Create(filename)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	f.WriteString(strings.Replace(commentRouterTemplate, "{{.commentControllerRouter}}", code, -1))

	return nil
}

// parse target dir's controller comment routers
func parseAll(targetPath string) []ControllerCommentRouter {
	astPkgs, err := parser.ParseDir(
		token.NewFileSet(),
		targetPath,
		func(info os.FileInfo) bool { // filter .go files
			name := info.Name()
			return !info.IsDir() && !strings.HasPrefix(name, ".") && strings.HasSuffix(name, ".go")
		},
		parser.ParseComments)
	if err != nil {
		log.Fatalln(err.Error())
	}

	routerList := make([]ControllerCommentRouter, 0)
	for _, pkg := range astPkgs {
		for _, fl := range pkg.Files {
			cr := parseFile(fl)
			routerList = append(routerList, cr)
		}
	}

	return routerList
}

func parseFile(f *ast.File) ControllerCommentRouter {
	// 1. parse file @prefix
	prefix := parsePrefix(f)

	// 2. parse method comment to get HTTP METHOD and request path
	crouter := ControllerCommentRouter{
		Pkg:            f.Name.String(),
		Controller:     "",
		CommentRouters: make([]CommentRouter, 0),
	}
	for _, d := range f.Decls {
		switch specDecl := d.(type) {
		case *ast.FuncDecl:
			if specDecl.Recv == nil {
				continue
			}

			// Check that the type is correct first before throwing to parser
			exp, ok := specDecl.Recv.List[0].Type.(*ast.StarExpr)
			if !ok {
				continue
			}

			crouter.Controller = fmt.Sprintf("%v", exp.X)
			method := specDecl.Name
			for _, l := range specDecl.Doc.List {
				httpMethods, path, isValid := parseValidRouterTag(l.Text)
				if !isValid {
					continue
				}

				crouter.CommentRouters = append(crouter.CommentRouters, CommentRouter{
					Method:     method.String(),
					Router:     fmt.Sprintf("/%s/%s", strings.Trim(prefix, "/"), strings.Trim(path, "/")),
					HTTPMethod: httpMethods,
				})

				// only identify first effective comment router
				// e.g:
				// @get,post /example/hello
				// @put /example/hello
				// only first record will be parsed.
				break
			}
		}
	}

	return crouter
}

func parsePrefix(f *ast.File) string {
	for _, cg := range f.Comments {
		if !strings.HasPrefix(strings.TrimSpace(cg.Text()), tagPrefix) {
			continue
		}

		line := strings.TrimSpace(cg.Text())
		line = strings.TrimSpace(strings.TrimPrefix(line, tagPrefix))
		arr := strings.SplitN(line, " ", 1)
		if len(arr) != 1 ||
			!strings.HasPrefix(arr[0], "/") {
			log.Fatalln(fmt.Sprintf("invalid comment router, comment: %s", cg.Text()))
		}
		return fmt.Sprintf("/%s", strings.Trim(arr[0], "/"))
	}

	return ""
}

// parse method comment to get HTTP Method, request path and return isValid to check it
func parseValidRouterTag(line string) (httpMethods []string, path string, isValid bool) {
	matches := routeRegex.FindStringSubmatch(line)
	if len(matches) < 3 {
		return httpMethods, path, false
	}

	// parse HTTP METHOD and path
	if strings.HasPrefix(matches[1], "/") { // use default HTTP METHOD
		// e.g: @/home/demo
		httpMethods = []string{"GET", "POST"}
		path = matches[1]
	} else {
		// e.g: @get,post /home/demo
		httpMethods = strings.Split(strings.ToUpper(matches[1]), ",")
		for _, m := range httpMethods {
			if _, ok := HTTP_METHOD[m]; !ok {
				isValid = false
				return
			}
		}
		path = matches[2]
	}

	isValid = true
	return
}
